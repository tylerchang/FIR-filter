<!DOCTYPE REFENTRY PUBLIC "-//Sun Microsystems//DTD DocBook V3.0-Based SolBook Subset V2.0//EN" [
<!--ArborText, Inc., 1988-1998, v.4001-->
<!ENTITY % javaents SYSTEM "javaman.ent">
%javaents;
]>
<?Pub UDT _bookmark _target>
<?Pub EntList minus bsol>
<?Pub Inc>
<refentry id="keytool-1">
<!--@(#)keytool.1 1.12 01/03/14 SMI;-->
<refmeta><refentrytitle>keytool</refentrytitle><manvolnum>1</manvolnum>
<refmiscinfo class="date">2001 年 11 月 30 日</refmiscinfo>
<refmiscinfo class="sectdesc">&man1;</refmiscinfo>
<refmiscinfo class="software">&java-release;</refmiscinfo>
<refmiscinfo class="arch">generic</refmiscinfo>
<refmiscinfo class="copyright"> Copyright 2001 Sun Microsystems, Inc. All rights reserved.  Copyright 2001 Sun Microsystems, Inc. Tous droits r&eacute;serv&eacute;s.</refmiscinfo>
</refmeta>
<refnamediv><refname>keytool</refname><refpurpose>鍵と証明書の管理ツール</refpurpose></refnamediv>
<refsynopsisdiv><title>&synp-tt;</title>
<cmdsynopsis><command>keytool</command><arg choice="opt"><replaceable>subcommands</replaceable></arg>
</cmdsynopsis></refsynopsisdiv>
<refsect1><title>&desc-tt;</title>
<indexterm id="keytool-1-indx-1"><primary sortas="key and certificate management tool">key and certificate management tool &mdash; keytool</primary></indexterm><indexterm id="keytool-1-indx-2"><primary sortas="keytool">keytool &mdash; key and certificate management tool</primary></indexterm>
<para><command>keytool</command> は、鍵と証明書を管理するためのユーティリティです。<command>keytool</command> を使うと、自分の公開鍵と非公開鍵のペア、および関連する証明書を管理し、デジタル署名を使った自己認証 (ほかのユーザまたはサービスに対して自分自身を認証すること) や、データの完全性と認証に関するサービスに利用することができます。<command>keytool</command> では、通信相手の公開鍵を (証明書の形で) キャッシュすることもできます。</para>
<para>「証明書」とは、あるエンティティからのデジタル署名付きの文書のことです。証明書には、ほかのあるエンティティ (人物、会社など) の公開鍵 (およびその他の情報) が特別な値を持っていることが書かれています (後述の「証明書」を参照)。データにデジタル署名が付いている場合は、デジタル署名を検証することで、データの完全性およびデータが本物であることをチェックできます。データの「完全性」とは、データが変更されたり、改変されたりしていないことを意味します。また、データが「本物である」とは、そのデータが、データを作成して署名したと称する人物から実際に渡されたデータであることを意味します。</para>
<para><command>keytool</command> は、鍵と証明書を「キーストア」に格納します。デフォルトのキーストアの実装は、キーストアをファイルとして実装しています。キーストアは、非公開鍵をパスワードで保護します。</para>
<para><citerefentry><refentrytitle>jarsigner</refentrytitle><manvolnum>1</manvolnum></citerefentry> ツールは、キーストアの情報を使って Java Archive (<acronym>JAR</acronym>) ファイルに対するデジタル署名の生成と検証を行います。<acronym>JAR</acronym> ファイルは、クラスファイル、イメージ、サウンド、およびその他のデジタルデータを単一のファイルにパッケージ化します。<citerefentry><refentrytitle>jarsigner</refentrytitle><manvolnum>1</manvolnum></citerefentry> は、<acronym>JAR</acronym> ファイルに付属する証明書 (JAR ファイルの署名ブロックファイルに含まれている証明書) を使って JAR ファイルのデジタル署名を検証し、証明書の公開鍵が「信頼」できるかどうか、つまり、該当する公開鍵が、指定されたキーストアに含まれているかどうかを調べます。</para>
<para><emphasis>注: </emphasis><command>keytool</command> ツールと <citerefentry><refentrytitle>jarsigner</refentrytitle><manvolnum>1</manvolnum></citerefentry> ツールは、JDK 1.1 で提供されていた <command>javakey</command> ツールを完全に置き換えるものです。これらの新しいツールは <command>javakey</command> よりも多くの機能を備えており、キーストアと非公開鍵をパスワードで保護する機能や、署名の生成に加えて署名を検証する機能を持っています。新しいキーストアアーキテクチャは、<command>javakey</command> が作成して管理していたアイデンティティデータベースに代わるものです。<option>identitydb</option> サブコマンドを使うと、アイデンティティデータベースの情報をキーストアにインポートできます。</para>
<refsect2><title>キーストアのエントリ</title>
<indexterm id="keytool-1-indx-3"><primary sortas="keytool">keytool &mdash; key and certificate management tool</primary><secondary>Keystore Entries</secondary></indexterm>
<para>キーストアのエントリには、次の 2 つの種類があります。</para>
<orderedlist>
<listitem><para><literal>鍵のエントリ</literal></para>
<para>各エントリは、非常に重要な暗号化の鍵の情報を保持します。この情報は、許可していないアクセスを防ぐために、保護された形で格納されます。一般に、この種のエントリとして格納される鍵は、秘密鍵か、対応する公開鍵の証明連鎖を伴う非公開鍵です。<command>keytool</command> ツールと <citerefentry><refentrytitle>jarsigner</refentrytitle><manvolnum>1</manvolnum></citerefentry> ツールはこのうち後者の方、つまり非公開鍵および関連する証明連鎖だけを扱います。</para>
</listitem><listitem><para><literal>信頼できる証明書のエントリ</literal></para>
<para>各エントリは、第三者からの公開鍵証明書を 1 つ含んでいます。この証明書は、「信頼できる証明書」と呼ばれます。それは、証明書内の公開鍵が、証明書の「主体」(所有者) によって特定されるアイデンティティに由来するものであることを、キーストアの所有者が信頼するからです。証明書の発行者は、証明書に署名を付けることによって、その内容を保証します。</para>
</listitem></orderedlist>
</refsect2>
<refsect2><title>キーストアの別名</title>
<indexterm id="keytool-1-indx-4"><primary sortas="keytool">keytool &mdash; key and certificate management tool</primary><secondary>Keystore Aliases</secondary></indexterm>
<para>キーストアのすべてのエントリ (鍵および信頼できる証明書) は、一意の「別名」を介してアクセスされます。別名では、大文字と小文字は区別されません。したがって、別名 Hugo と hugo は、どちらも同じキーストアエントリを指します。</para>
<para><option>genkey</option> サブコマンドを使って鍵のペア (公開鍵と非公開鍵) を生成したり、<option>import</option> サブコマンドを使って、信頼できる証明書のリストに証明書または証明連鎖を追加するなど、キーストアにエンティティを追加するときは、別名を指定します。これ以後、<command>keytool</command> コマンドでエンティティを参照する場合は、このときに指定した別名を使用する必要があります。</para>
<para>たとえば、<literal>duke</literal> という別名を使って新しい公開鍵と非公開鍵のペアを生成し、公開鍵を自己署名証明書 (証明連鎖を参照) でラップするとします。この場合は、次のコマンドを実行します。<informalexample><screen>example% <userinput>keytool -genkey -alias duke -keypass dukekeypasswd</userinput></screen>
</informalexample></para>
<para>ここでは、初期パスワードとして <literal>dukekeypasswd</literal> を指定しています。以後、別名 <literal>duke</literal> に関連付けられた非公開鍵にアクセスするコマンドを実行するときは、このパスワードが必要になります。<literal>duke</literal> の非公開鍵のパスワードをあとから変更するには、次のコマンドを実行します。<informalexample><screen>example% <userinput>keytool -keypasswd -alias duke -keypass &bsol; 
      dukekeypasswd -new newpass</userinput></screen>
</informalexample></para>
<para>パスワードが、<literal>dukekeypasswd</literal> から <literal>newpass</literal> に変更されます。</para>
<para><emphasis>注:</emphasis> テストを目的とする場合、または安全であることがわかっているシステムで実行する場合以外は、コマンド行やスクリプトでパスワードを指定しないでください。必要なパスワードのオプションをコマンド行で指定しなかった場合は、パスワードの入力を求められます。password プロンプトでパスワードを入力すると、入力したパスワードがエコーされ、そのまま画面に表示されます。このため、周囲にほかのユーザがいる場合は、パスワードを見られないように注意してください。</para>
</refsect2>
<refsect2><title>キーストアの場所</title>
<indexterm id="keytool-1-indx-5"><primary sortas="keytool">keytool &mdash; key and certificate management tool</primary><secondary>Keystore Location</secondary></indexterm>
<para><command>keytool</command> の各コマンドには、<option>keystore</option> オプションがあります。このオプションでは、<command>keytool</command>で管理するキーストアに対応する永続的なキーストアファイルの名前と場所を指定します。キーストアは、デフォルトではユーザのホームディレクトリの <filename>.keystore</filename> という名前のファイルに格納されます。ユーザのホームディレクトリは、user.home システムプロパティによって決まります。Solaris システムの場合、user.home はデフォルトでユーザのホームディレクトリになっています。</para>
</refsect2>
<refsect2><title>キーストアの作成</title>
<indexterm id="keytool-1-indx-6"><primary sortas="keytool">keytool &mdash; key and certificate management tool</primary><secondary>Keystore Creation</secondary></indexterm>
<para>まだ存在していないキーストアに対し、<option>genkey</option>、<option>import</option>、または <option>identitydb</option> サブコマンドを使ってデータを追加すると、キーストアが作成されます。</para>
<para>具体的には、<option>keystore</option> オプションでキーストアを指定していて、このキーストアがまだ存在していない場合は、指定したキーストアが作成されます。</para>
<para><option>keystore</option> オプションを指定しなかった場合、デフォルトのキーストアは、ホームディレクトリ内の <filename>.keystore</filename> という名前のファイルになります。このファイルがまだ存在していない場合は作成されます。</para>
</refsect2>
<refsect2><title>キーストアの実装</title>
<indexterm id="keytool-1-indx-7"><primary sortas="keytool">keytool &mdash; key and certificate management tool</primary><secondary>Keystore Implementation</secondary></indexterm>
<para>java.security パッケージで提供される <literal>KeyStore</literal> クラスには、キーストア内の情報に対するアクセスと変更を行うための明確に定義されたインタフェースが用意されています。キーストアの固定実装としては、それぞれが特定の「タイプ」のキーストアを対象とする複数の異なる実装が存在可能です。</para>
<para>現在、<command>keytool</command> と <citerefentry><refentrytitle>jarsigner</refentrytitle><manvolnum>1</manvolnum></citerefentry> の 2 つのコマンド行ツールと、<literal>policytool</literal> という名前の 1 つの <acronym>GUI</acronym> ベースのツールがあります。<literal>KeyStore</literal> は public として使用可能なので、JDK ユーザは <literal>KeyStore</literal> を使ったほかのセキュリティアプリケーションも作成できます。</para>
<para>キーストアには、Sun が提供する組み込みのデフォルトの実装があります。これは、JKS という名前の独自のキーストアタイプ (形式) を利用するもので、キーストアをファイルとして実装しています。この実装では、個々の非公開鍵は個別のパスワードによって保護され、キーストア全体の完全性も (非公開鍵とは別の) パスワードによって保護されます。</para>
<para>キーストアの実装は、プロバイダベースです。具体的には、<literal>KeyStore</literal> が提供するアプリケーションインタフェースは、Service Provider Interface (SPI) という形で実装されています。つまり、対応する <literal>KeystoreSpi</literal> 抽象クラス (これも <literal>java.security</literal> パッケージに含まれている) があり、このクラスが Service Provider Interface のメソッドを定義しています。これらのメソッドは、「プロバイダ」が実装しなければなりません。ここで、「プロバイダ」とは、Java Security <acronym>API</acronym> によってアクセス可能なサービスのサブセットに対し、その固定実装を提供するパッケージまたはパッケージの集合のことです。したがって、キーストアの実装を提供するには、「Java 暗号化アーキテクチャ用プロバイダの実装方法」で説明しているように、クライアントが「プロバイダ」を実装し、<literal>KeystoreSpi</literal>サブクラスの実装を提供する必要があります。</para>
<para>アプリケーションでは、<literal>KeyStore</literal> クラスが提供する getInstance ファクトリメソッドを使うことで、さまざまなプロバイダから異なる「タイプ」のキーストアの実装を選択できます。キーストアのタイプは、キーストア情報の格納形式とデータ形式、およびキーストア内の非公開鍵とキーストア自体の完全性を保護するために使われるアルゴリズムを定義します。異なるタイプのキーストアの実装には、互いに互換性はありません。</para>
<para><command>keytool</command> は、任意のファイルベースのキーストア実装で動作します。<command>keytool</command> は、コマンド行から渡されたキーストアの場所をファイル名として扱い、これを <literal>FileInputStream</literal> に変換して、<literal>FileInputStream</literal> からキーストアの情報をロードします。一方、<citerefentry><refentrytitle>jarsigner</refentrytitle><manvolnum>1</manvolnum></citerefentry> ツールと policytool ツールは、<acronym>URL</acronym> で指定可能な任意の場所からキーストアを読み込むことができます。</para>
<para><command>keytool</command> と <citerefentry><refentrytitle>jarsigner</refentrytitle><manvolnum>1</manvolnum></citerefentry> の場合、<option>storetype</option> オプションを使ってコマンド行でキーストアのタイプを指定できます。<literal>Policy Tool</literal> の場合は、[Edit] メニューの [Change Keystore] コマンドを使ってキーストアのタイプを指定できます。</para>
<para>キーストアのタイプを明示的に指定しない場合、<literal>keytool</literal>、<literal>jarsigner</literal>、および  <literal>policytool</literal> の各ツールは、セキュリティプロパティファイル内で指定された  <literal>keystore.type</literal> プロパティの値に基づいてキーストアの実装を選択します。セキュリティプロパティファイルは、<filename>java.security</filename> という名前で JDK セキュリティプロパティディレクトリ <filename>java.home/lib/security</filename> に置かれています。<filename>java.home</filename> は、JDK のインストール先ディレクトリです。</para>
<para>各ツールは、<literal>keystore.type</literal> の値を取得し、この値で指定されたタイプのキーストアを実装しているプロバイダが見つかるまで、現在インストールされているすべてのプロバイダを調べます。目的のプロバイダが見つかると、そのプロバイダからのキーストアの実装を使います。</para>
<para><literal>KeyStore</literal> クラスでは <literal>getDefaultType</literal> という名前の static メソッドが定義されており、アプリケーションとアプレットはこのメソッドを使うことで <literal>keystore.type</literal> プロパティの値を取得できます。次のコードは、デフォルトのキーストアタイプ (<literal>keystore.type</literal> プロパティで指定されたタイプ) のインスタンスを生成します。<informalexample><programlisting>KeyStore keyStore = KeyStore.getInstance(KeyStore.getDefaultType());</programlisting>
</informalexample></para>
<para>デフォルトのキーストアタイプは jks (Sun が提供する独自のタイプのキーストアの実装) です。これは、セキュリティプロパティファイル内の次の行によって指定されています。<informalexample><programlisting>keystore.type=jks</programlisting>
</informalexample></para>
<para>各ツールでデフォルト以外のキーストアの実装を使用するには、上の行を変更して別のキーストアのタイプを指定します。</para>
<para>たとえば、<literal>pkcs12</literal> と呼ばれるタイプのキーストアの実装を提供しているプロバイダパッケージを使用するには、上の行を次のように変更します。<informalexample><programlisting>keystore.type=pkcs12</programlisting>
</informalexample></para>
<para><emphasis>注:</emphasis> キーストアのタイプの指定では、大文字と小文字は区別されません。たとえば、JKS と jks は同じものとして扱われます。</para>
</refsect2>
<refsect2><title>サポートされるアルゴリズムと鍵のサイズ</title>
<indexterm id="keytool-1-indx-8"><primary sortas="keytool">keytool &mdash; key and certificate management tool</primary><secondary>Supported Algorithms and Key Sizes</secondary></indexterm>
<para><command>keytool</command> では、登録されている暗号化サービスプロバイダが提供する鍵のペア生成および署名アルゴリズムのうち、任意のアルゴリズムを指定できます。つまり、さまざまなコマンドで指定する <option>keyalg</option> オプションと <option>sigalg</option> オプションは、プロバイダ実装によってサポートされていなければなりません。デフォルトの鍵のペア生成アルゴリズムは DSA です。署名アルゴリズムは、基になる非公開鍵のアルゴリズムから派生します。基になる非公開鍵が <literal>DSA</literal> タイプである場合、デフォルトの署名アルゴリズムは <literal>SHA1withDSA</literal> になり、基になる非公開鍵が <literal>RSA</literal> タイプである場合は、デフォルトの署名アルゴリズムは <literal>MD5withRSA</literal> になります。</para>
<para><literal>DSA</literal> 鍵のペアを生成する場合、鍵のサイズは 512 〜 1024 ビットである必要があります。また、鍵のサイズは、64 の倍数である必要があります。デフォルトの鍵のサイズは、どのアルゴリズムの場合でも 1024 ビットです。</para>
</refsect2>
<refsect2><title>証明書</title>
<indexterm id="keytool-1-indx-9"><primary sortas="keytool">keytool &mdash; key and certificate management tool</primary><secondary>Certificates</secondary></indexterm>
<para>証明書 (公開鍵証明書とも呼ぶ) とは、あるエンティティ (「発行者」) からのデジタル署名付きの文書のことです。証明書には、ほかのあるエンティティ (「署名者」) の公開鍵 (およびその他の情報) が特別な値を持っていることが書かれています。</para>
<para>以下では、いくつかの重要な用語について説明します。</para>
<variablelist termlength="medium"><varlistentry><term remap="20"><literal>公開鍵</literal></term><listitem><para>公開鍵は、特定のエンティティに関連付けられた数です。公開鍵は、該当するエンティティとの間に信頼できる関係を持つ必要があるすべての人に対して公開することを意図したものです。公開鍵は、署名を検証するのに使われます。</para>
</listitem></varlistentry>
<varlistentry><term><literal>デジタル署名</literal></term><listitem><para>データが「デジタル署名」されると、そのデータは、エンティティの「アイデンティティ」と、そのエンティティがデータの内容について知っていることを証明する署名とともに格納されます。エンティティの非公開鍵を使ってデータに署名を付けると、データの偽造は不可能になります。</para>
</listitem></varlistentry>
<varlistentry><term><literal>アイデンティティ </literal></term><listitem><para>エンティティを特定するための既知の方法です。システムによっては、公開鍵をアイデンティティにするものがあります。公開鍵のほかにも、Unix  <acronym>UID</acronym> や電子メールアドレス、X.509 識別名など、さまざまなものをアイデンティティとすることができます。</para>
</listitem></varlistentry>
<varlistentry><term><literal>署名</literal></term><listitem><para>署名は、なんらかのデータを基にエンティティ (署名者。証明書に関しては発行者とも呼ばれる) の非公開鍵を使って計算されます。</para>
</listitem></varlistentry>
<varlistentry><term><literal>非公開鍵</literal></term><listitem><para>非公開鍵は特定のエンティティだけが知っている数のことで、この数のことを、そのエンティティの非公開鍵といいます。非公開鍵は、ほかに知られないように 秘密にしておくことが前提になっています。どのような「公開鍵暗号化システム」でも、非公開鍵と公開鍵が対 (ペア) で存在します。<acronym>DSA</acronym> などの典型的な公開鍵暗号化システムの場合、1 つの非公開鍵は正確に 1 つの公開鍵に対応します。非公開鍵は、署名を計算するのに使われます。</para>
</listitem></varlistentry>
<varlistentry><term><literal>エンティティ</literal></term><listitem><para>エンテンティは、人、組織、プログラム、コンピュータ、企業、銀行など、一定の度合で信頼の対象となるさまざまなものを指します。</para>
</listitem></varlistentry>
</variablelist>
<para>公開鍵暗号化では、その性質上、ユーザの公開鍵にアクセスする必要があります。大規模なネットワーク環境では、互いに通信しているエンティティ間で以前の関係が引き続き確立されていると仮定したり、使われているすべての公開鍵を収めた信頼できるリポジトリが存在すると仮定したりすることは不可能です。証明書は、このような公開鍵配布の問題に対する解決策として考案されました。「証明書発行局」(CA) は、信頼できる第三者として機能します。<acronym>CA</acronym> は、ほかのエンティティの証明書に署名する (発行する) 行為を、信頼され任されているエンティティ (企業など) です。<acronym>CA</acronym> は法律上の契約に拘束されるので、有効かつ信頼できる証明書だけを作成するものとして扱われます。VeriSign、Thawte、Entrust をはじめ、多くの <acronym>CA</acronym> が存在します。<trademark>Netscape</trademark> や Microsoft の認証サーバ、Entrust の <acronym>CA</acronym> 製品などを所属組織内で利用すれば、独自の証明書発行局を運営することも可能です。</para>
<para><command>keytool</command> を使うと、証明書の表示、インポート、およびエクスポートを行うことができます。また、自己署名証明書を生成することもできます。</para>
<para>現在、<command>keytool</command> は X.509 証明書を対象にしています。</para>
</refsect2>
<refsect2><title>X.509 証明書</title>
<indexterm id="keytool-1-indx-10"><primary sortas="keytool">keytool &mdash; key and certificate management tool</primary><secondary>X.509 Certificates</secondary></indexterm>
<para>X.509 規格では、証明書に含める情報が定義されており、この情報を証明書に書き込む方法 (データ形式) についても記述されています。すべての X.509 証明書は、署名のほかに次のデータを含んでいます。</para>
<variablelist termlength="wholeline"><varlistentry><term>バージョン</term><listitem><para>証明書に適用される X.509 規格のバージョンを特定します。証明書に指定できる情報は、バージョンによって異なります。これまでに、3 つのバージョンが定義されています。<command>keytool</command> では、v1、v2、および v3 の証明書のインポートとエクスポートが可能です。<command>keytool</command> が生成するのは、v1 の証明書です。</para>
</listitem></varlistentry>
<varlistentry><term>シリアル番号</term><listitem><para>証明書を作成したエンティティは、そのエンティティが発行するほかの証明書と区別するために、証明書にシリアル番号を割り当てます。この情報は、さまざまな方法で使われます。たとえば、証明書が取り消されると、シリアル番号が証明書の取り消しリスト (<acronym>CRL</acronym>) に格納されます。</para>
</listitem></varlistentry>
<varlistentry><term>署名アルゴリズム識別子</term><listitem><para>証明書に署名を付けるときに <acronym>CA</acronym> が使ったアルゴリズムを特定します。</para>
</listitem></varlistentry>
<varlistentry><term>発行者名</term><listitem><para>証明書に署名を付けたエンティティの X.500 識別名です。エンティティは、通常は <acronym>CA</acronym> です。この証明書を使うことは、証明書に署名を付けたエンティティを信頼することを意味します。「ルート」つまりトップレベルの <acronym>CA</acronym> の証明書など、場合によっては発行者が自身の証明書に署名を付けることがある点に注意してください。</para>
</listitem></varlistentry>
<varlistentry><term>有効期間</term><listitem><para>各証明書は、限られた期間だけ有効になります。この期間は開始の日時と終了の日時によって指定され、数秒の短い期間から 100 年という長期にわたることもあります。有効期間は、証明書の署名に使われた非公開鍵の強度や証明書に対して支払われる金額など、さまざまな要因を考慮して選択されます。関連付けられている非公開鍵が他人に知られない限り、エンティティが証明書を信頼できる期間が有効期間です。</para>
</listitem></varlistentry>
<varlistentry><term>主体名</term><listitem><para>証明書に関連付けられた公開鍵を所有しているエンティティの名前です。インターネット上で一意の名前にするため、この名前には X.500 規格が使われます。これは、エンティティの X.500 識別名 (<acronym>DN</acronym>) です。たとえば、次のようになります。<informalexample><programlisting>CN=Java Duke, OU=Java Software Division, O=Sun Microsystems Inc, C=US</programlisting>
</informalexample>これらはそれぞれ主体の通称、組織単位、組織、国を表します。</para>
</listitem></varlistentry>
<varlistentry><term>主体の公開鍵情報 </term><listitem><para>名前を付けられたエンティティの公開鍵とアルゴリズム識別子です。アルゴリズム識別子では、公開鍵に対して使われている公開鍵暗号化システムおよび関連する鍵パラメータが指定されています。</para>
</listitem></varlistentry>
</variablelist>
<para><replaceable>X.509 Version 1</replaceable> は、1988 年から利用されて広く普及しており、もっとも一般的です。</para>
<para><replaceable>X.509 Version 2</replaceable> では、主体や発行者の名前をあとで再利用できるようにするために、主体と発行者とに一意識別子の概念が導入されました。ただし、ほとんどの証明書プロファイル文書では、名前の再利用および証明書での一意識別子の利用を推奨していません。Version 2 の証明書は、広く普及しているとはいえません。</para>
<para><replaceable>X.509 Version 3</replaceable> はもっとも新しい (1996 年) 規格で、エクステンションの概念をサポートしています。エクステンションは誰でも定義することができ、証明書に含めることができます。現在使われている一般的なエクステンションとしては、<literal>KeyUsage</literal> (「署名専用」など、鍵の使用を特定の目的に制限する)、<literal>AlternativeNames</literal> (たとえば、<acronym>DNS</acronym> 名、電子メールアドレス、IP アドレスなど、ほかのアイデンティティを公開鍵に関連付けることができる) などがあります。エクステンションには、critical というマークを付けて、そのエクステンションのチェックと使用を義務づけることができます。たとえば、critical とマークされ、<literal>keyCertSign</literal> が設定された <literal>KeyUsage</literal> エクステンションが証明書に含まれている場合、この証明書を <acronym>SSL</acronym> 通信中に提示すると、証明書が拒否されます。これは、証明書のエクステンションによって、関連する非公開鍵が証明書の署名専用として指定されており、SSL では使用できないためです。</para>
<para>証明書のすべてのデータは、ASN.1/DER と呼ばれる 2 つの関連規格を使って符号化されます。「<citetitle>Abstract Syntax Notation 1</citetitle>」はデータについて記述しています。「<citetitle>Definite Encoding Rules</citetitle>」は、データの保存および転送の方法について記述しています。</para>
</refsect2>
<refsect2><title>X.500 識別名</title>
<indexterm id="keytool-1-indx-11"><primary sortas="keytool">keytool &mdash; key and certificate management tool</primary><secondary>X.500 Distinguished Names</secondary></indexterm>
<para>X.500 識別名は、エンティティを特定するために使われます。たとえば、X.509 証明書の subject フィールドと issuer (署名者) フィールドで指定される名前は、X.500 識別名です。<command>keytool</command> は、次のサブパートをサポートしています。<variablelist termlength="medium"><varlistentry><term><literal>commonName</literal></term><listitem><para>人の通称。「Susan Jones」など</para>
</listitem></varlistentry>
<varlistentry><term><literal>organizationUnit</literal></term><listitem><para>小さな組織 (部、課など) の名称。「仕入部」など</para>
</listitem></varlistentry>
<varlistentry><term><literal>name</literal></term><listitem><para>「ABCSystems, Inc.」など</para>
</listitem></varlistentry>
<varlistentry><term><literal>localityName</literal></term><listitem><para>地域 (都市) 名。「Palo Alto」など</para>
</listitem></varlistentry>
<varlistentry><term><literal>stateName</literal></term><listitem><para>州名または地方名。「California」など</para>
</listitem></varlistentry>
<varlistentry><term><literal>country</literal></term><listitem><para>2 文字の国番号。「CH」など</para>
</listitem></varlistentry>
</variablelist></para>
<para><option>genkey</option> サブコマンドまたは <option>selfcert</option> サブコマンドの <option>dname</option> オプションの値として識別名文字列を指定する場合は、次の形式で指定する必要があります。<informalexample><screen>CN=cName, OU=orgUnit, O=org, L=city, S=state, C=countryCode</screen>
</informalexample></para>
<para>イタリック体の項目は、実際に指定する値を表します。短縮形のキーワードの意味は、次のとおりです。<informalexample><screen>CN=commonName
OU=organizationUnit
O=organizationName
L=localityName
S=stateName
C=country</screen>
</informalexample></para>
<para>次に示すのは、識別名文字列の例です。<informalexample><screen>CN=Mark Smith, OU=Java, O=Sun, L=Cupertino, S=California, C=US</screen>
</informalexample></para>
<para>次は、この文字列を使ったコマンドの例です。<informalexample><screen>example% <userinput>keytool -genkey -dname "CN=Mark Smith, OU=Java, 
O=Sun, L=Cupertino, S=California, C=US" -alias mark</userinput></screen>
</informalexample></para>
<para>キーワードの短縮形では、大文字と小文字は区別されません。たとえば、<literal>CN</literal>、<literal>cn</literal>、および <literal>Cn</literal> は、どれも同じものとして扱われます。</para>
<para>キーワードの短縮形では、大文字と小文字は区別されません。たとえば、<literal>CN</literal> 、<literal>cn</literal>、および <literal>cn</literal> は、どれも同じものとして扱われます。</para>
<para>一方、キーワードの指定順序には意味があり、各サブコンポーネントは上に示した順序で指定する必要があります。ただし、サブコンポーネントをすべて指定する必要はありません。たとえば、次のように一部のサブコンポーネントだけを指定できます。<informalexample><screen>CN=Steve Meier, OU=SunSoft, O=Sun, C=US</screen>
</informalexample></para>
<para>識別名文字列の値にコンマが含まれる場合にコマンド行の文字列を指定するときには、次のように、コンマを &bsol; 文字でエスケープする必要があります。<informalexample><screen>cn=peter schuster, o=Sun Microsystems&bsol;, Inc., o=sun, c=us</screen>
</informalexample></para>
<para>識別名文字列をコマンド行で指定する必要はありません。識別名を必要とするコマンドを実行するときに、コマンド行で識別名を指定しなかった場合は、各サブコンポーネントの入力を求められます。この場合は、コンマを &bsol; 文字でエスケープする必要はありません。</para>
</refsect2>
<refsect2><title>インターネット RFC 1421 証明書エンコーディング</title>
<indexterm id="keytool-1-indx-12"><primary sortas="keytool">keytool &mdash; key and certificate management tool</primary><secondary>The Internet RFC 1421 Certificate Encoding Standard</secondary></indexterm>
<para>多くの場合、証明書は、バイナリエンコーディングではなく、インターネット RFC 1421 規格で定義されているプリント可能エンコーディング方式を使って格納されます。「Base 64 エンコーディング」とも呼ばれるこの証明書形式では、電子メールやその他の機構を通じて、ほかのアプリケーションに証明書を容易にエクスポートできます。</para>
<para><option>import</option> サブコマンドと <option>printcert</option> サブコマンドでは、この形式の証明書とバイナリエンコーディングの証明書を読み込むことができます。</para>
<para><option>export</option> サブコマンドでは、デフォルトでバイナリエンコーディングの証明書が出力されます。ただし、<option>rfc</option> オプションを指定した場合は、プリント可能エンコーディング方式の証明書が出力されます。</para>
<para><option>list</option> サブコマンドでは、デフォルトで証明書の MD5 フィンガープリントが出力されます。<option>v</option> オプションを指定すると、人間が読むことのできる形式で証明書が出力されます。一方、<option>rfc</option> オプションを指定すると、プリント可能エンコーディング方式で証明書が出力されます。</para>
<para>プリント可能エンコーディング方式で符号化された証明書は、次の行で始まります。</para>
<para><screen>-----BEGIN CERTIFICATE-----</screen></para>
<para>最後は、次の行で終わります。</para>
<para><screen>-----END CERTIFICATE-----</screen></para>
</refsect2>
<refsect2><title>証明連鎖</title>
<indexterm id="keytool-1-indx-13"><primary sortas="keytool">keytool &mdash; key and certificate management tool</primary><secondary>Certificate Chains</secondary></indexterm>
<para><command>keytool</command> では、非公開鍵および関連する証明「連鎖」を含むキーストアの「鍵」エントリを作成し、管理することができます。このようなエントリでは、非公開鍵に対応する公開鍵は、連鎖の最初の証明書に含まれています。</para>
<para>鍵を初めて作成すると (<option>genkey</option> サブコマンドを参照)、「自己署名証明書」という 1 つの要素だけを含む連鎖が開始されます。自己署名証明書とは、発行者 (署名者) と主体 (証明書によって認証される公開鍵を所有しているエンティティ) とが同一の証明書のことです。<option>genkey</option> サブコマンドを呼び出して新しい公開鍵と非公開鍵のペアを作成すると、公開鍵は常に自己署名証明書でラップされます。</para>
<para>このあと、証明書署名要求 (<acronym>CSR</acronym>) が生成されて (<option>certreq</option> サブコマンドを参照)、CSR が証明書発行局 (<acronym>CA</acronym>) に送信されると、<acronym>CA</acronym> からの応答がインポートされ (<option>import</option> コマンドを参照)、元の自己署名証明書は証明連鎖によって置き換えられます。連鎖の最後にあるのは、主体の公開鍵を認証した CA が発行した証明書 (応答) です。連鎖内のその前の証明書は、「CA」の公開鍵を認証する証明書です。</para>
<para><acronym>CA</acronym> の公開鍵を認証する証明書は、多くの場合、自己署名証明書 (つまり <acronym>CA</acronym> が自身の公開鍵を認証した証明書) であり、これは連鎖の最初の証明書になります。場合によっては、<acronym>CA</acronym> が証明の連鎖を返すこともあります。この場合、連鎖内の最後の証明書 (<acronym>CA</acronym> によって署名され、鍵エントリの公開鍵を認証する証明書) に変わりはありませんが、連鎖内のその前の証明書は、<acronym>CSR</acronym> の送信先の <acronym>CA</acronym> とは「別の」<acronym>CA</acronym> によって署名され、<acronym>CSR</acronym> の送信先の <acronym>CA</acronym> の公開鍵を認証する証明書になります。さらに、連鎖内のその前の証明書は、次の <acronym>CA</acronym> の鍵を認証する証明書になります。以下同様に、自己署名された「ルート」証明書に達するまで連鎖が続きます。したがって、連鎖内の (最初の証明書以後の) 各証明書では、連鎖内の次の証明書の署名者の公開鍵が認証されていることになります。</para>
<para>多くの <acronym>CA</acronym> は、連鎖をサポートせずに発行済みの証明書だけを返します。特に、中間の <acronym>CA</acronym> が存在しないフラットな階層構造の場合は、その傾向が顕著です。このような場合は、キーストアにすでに格納されている信頼できる証明書情報から、証明連鎖を確立する必要があります。</para>
<para>別の応答形式 (PKCS#7 で定義されている形式) でも、発行済み証明書に加え、証明書連鎖のサポートが含まれています。<command>keytool</command> では、どちらの応答形式も扱うことができます。</para>
<para>トップレベル (ルート) <acronym>CA</acronym> の証明書は、自己署名証明書です。ただし、ルートの公開鍵に対する信頼は、ルートの証明書自体から導き出されるものではなく (たとえば、VeriSign ルート <acronym>CA</acronym> のような有名な識別名を使った自己署名証明書を作成すること自体は誰でも可能)、新聞などのほかの情報源に由来するものです。ルート <acronym>CA</acronym> の公開鍵は広く知られています。ルート <acronym>CA</acronym> の公開鍵を証明書に格納する理由は、証明書という形式にすることで多くのツールから利用できるようになるからにすぎません。つまり、証明書は、ルート CA の公開鍵を運ぶ「媒体」として利用されるだけです。ルート <acronym>CA</acronym> の証明書をキーストアに追加するときは、その前に証明書の内容を表示し (<option>printcert</option> オプションを使用)、表示されたフィンガープリントと、新聞やルート <acronym>CA</acronym> の Web ページなどから入手した既知のフィンガープリントとを比較する必要があります。</para>
</refsect2>
<refsect2><title>証明書のインポート</title>
<indexterm id="keytool-1-indx-14"><primary sortas="keytool">keytool &mdash; key and certificate management tool</primary><secondary>Importing Certificates</secondary></indexterm>
<para>証明書をファイルからインポートするには、<option>import</option> サブコマンドを使います。たとえば、次のようにします。<informalexample><screen>example% <userinput>keytool -import -alias joe -file jcertfile.cer</userinput></screen>
</informalexample></para>
<para>この例は、ファイル <literal>jcertfile.cer</literal> の証明書をインポートし、別名 <literal>joe</literal> によって特定されるキーストアエントリに証明書を格納します。</para>
<para>証明書のインポートには、次の 2 つの目的があります。</para>
<orderedlist>
<listitem><para>信頼できる証明書のリストに証明書を追加する</para>
</listitem><listitem><para><acronym>CA</acronym> に証明書署名要求 (<option>certreq</option> サブコマンドを参照) を送信した結果として、CA から受け取った証明書応答をインポートする</para>
</listitem></orderedlist>
<para>どちらの種類のインポートを行うかは、<option>alias</option> オプションの値によって指定します。指定した別名がデータベース内に存在し、その別名によって非公開鍵を持つエントリが特定される場合は、証明書応答のインポートが指定されたものとみなされます。<command>keytool</command> は、証明書応答内の公開鍵が、指定された別名で格納された公開鍵と一致するかどうかを調べ、一致しない場合は処理を行いません。指定された別名で特定されるキーストアエントリが、上記以外の種類のエントリである場合、証明書はインポートされません。指定された別名が存在しない場合は、別名が作成され、作成された別名は、インポートされた証明書に関連付けられます。</para>
</refsect2>
<refsect2><title>信頼できる証明書のインポートに関する注意事項</title>
<para>重要: 信頼できる証明書として証明書をインポートする前に、証明書の内容を慎重に調べてください。</para>
<itemizedlist>
<listitem><para>まず、証明書の内容を表示し (<option>printcert</option> サブコマンドを使用するか、または <option>noprompt</option> オプションを指定しないで <option>import</option> サブコマンドを使用)、表示された証明書のフィンガープリントが、期待されるフィンガープリントと一致するかどうかを確認します。たとえば、あるユーザから証明書が送られてきて、この証明書を <literal>/tmp/cert</literal> という名前でファイルに格納しているとします。この場合は、信頼できる証明書のリストにこの証明書を追加する前に、<option>printcert</option> サブコマンドを実行してフィンガープリントを表示できます。たとえば、次のようにします。<informalexample><screen>example% <userinput>keytool -printcert -file /tmp/cert
Owner: CN=ll, OU=ll, O=ll, L=ll, S=ll, C=ll
Issuer: CN=ll, OU=ll, O=ll, L=ll, S=ll, C=ll
Serial Number: 59092b34
Valid from: Thu Sep 25 18:01:13 PDT 1997 until: Wed Dec 24 17:01:13 PST 1997
Certificate Fingerprints:
MD5:  11:81:AD:92:C8:E5:0E:A2:01:2E:D4:7A:D7:5F:07:6F
SHA1: 20:B6:17:FA:EF:E5:55:8A:D0:71:1F:E8:D6:9D:C0:37:13:0E:5E:FE</userinput></screen>
</informalexample></para>
</listitem><listitem><para>次に、証明書を送信した人物に連絡し、この人物が提示したフィンガープリントと、上のコマンドで表示されたフィンガープリントとを比較します。フィンガープリントが一致すれば、送信途中でほかの何者か (攻撃者など) による証明書のすり替えが行われていないことを確認できます。送信途中でこの種の攻撃が行われていた場合、チェックを行わずに証明書をインポートすると、攻撃者によって署名されたすべてのもの (攻撃的意図を持つクラスファイルを含んだ <acronym>JAR</acronym> ファイルなど) を信頼することになります。</para>
<para><emphasis>注:</emphasis> 証明書をインポートする前に必ず <option>printcert</option> サブコマンドを実行しなければならないわけではありません。<option>import</option> サブコマンドを実行すると、キーストア内の信頼できる証明書のリストに証明書を追加する前に、証明書の情報が表示され、確認を求めるメッセージが表示されます。インポート操作は、この時点で中止できます。ただし、確認メッセージが表示されるのは、<option>import</option> サブコマンドを <option>noprompt</option> オプションを指定せずに実行した場合だけです。<option>noprompt</option> オプションが指定されている場合、ユーザとの対話は行われません。</para>
</listitem></itemizedlist>
</refsect2>
<refsect2><title>証明書のエクスポート</title>
<indexterm id="keytool-1-indx-15"><primary sortas="keytool">keytool &mdash; key and certificate management tool</primary><secondary>Exporting Certificates</secondary></indexterm>
<para>証明書をファイルにエクスポートするには、<option>export</option> サブコマンドを使います。たとえば、次のようにします。<informalexample><screen>example% <userinput>keytool -export -alias jane -file janecertfile.cer</userinput></screen>
</informalexample></para>
<para>この例は、<literal>jane</literal> の証明書をファイル <literal>janecertfile.cer</literal> にエクスポートします。<literal>jane</literal> が鍵エントリの別名である場合は、指定されたキーストアエントリの証明連鎖の最後の証明書をエクスポートします。この証明書は、<literal>jane</literal> の公開鍵を認証する証明書です。</para>
<para>一方、<literal>jane</literal> が、信頼できる証明書のエントリの別名である場合は、該当する信頼できる証明書がエクスポートされます。</para>
</refsect2>
<refsect2><title>証明書の表示</title>
<indexterm id="keytool-1-indx-16"><primary sortas="keytool">keytool &mdash; key and certificate management tool</primary><secondary>Displaying Certificates</secondary></indexterm>
<para>キーストアエントリの内容を表示するには、<option>list</option> サブコマンドを使います。たとえば、次のようにします。<informalexample><screen>example% <userinput>keytool -list -alias joe</userinput></screen>
</informalexample></para>
<para>次は、別名を指定しない例です。<informalexample><screen>example% <userinput>keytool -list</userinput></screen>
</informalexample></para>
<para>別名を指定しない場合は、キーストア全体の内容が表示されます。</para>
<para>ファイルに格納されている証明書の内容を表示するには、<option>printcert</option> サブコマンドを使います。たとえば、次のようにします。<informalexample><screen>example% <userinput>keytool -printcert -file certfile.cer</userinput></screen>
</informalexample></para>
<para>この例では、ファイル <literal>certfile.cer</literal> に格納されている証明書の情報が表示されます。</para>
<para><emphasis>注:</emphasis> このコマンドは、キーストアとは関係なく動作します。つまり、キーストアがない場合でも、ファイルに格納された証明書を表示できます。</para>
</refsect2>
<refsect2><title>自己署名証明書の生成</title>
<indexterm id="keytool-1-indx-17"><primary sortas="keytool">keytool &mdash; key and certificate management tool</primary><secondary>Generating a Self-signed Certificate</secondary></indexterm>
<para>「自己署名証明書」とは、発行者 (署名者) と主体 (証明書によって認証される公開鍵を所有しているエンティティ) とが同一の証明書のことです。<option>genkey</option> サブコマンドを呼び出して新しい公開鍵と非公開鍵のペアを作成すると、公開鍵は常に自己署名証明書でラップされます。</para>
<para>場合によっては、新しい自己署名証明書を作成したいことがあります。たとえば、同じ鍵のペアを別のアイデンティティ (識別名) で使いたい場合などです。例として、所属部課が変更になったとします。この場合は、次のようにします。</para>
<orderedlist>
<listitem><para>元の鍵エントリをコピー (複製) する (<option>keyclone</option> を参照)</para>
</listitem><listitem><para>新しい識別名を使って、複製したエントリの新しい自己署名証明書を生成する (以下を参照)</para>
</listitem><listitem><para>複製したエントリの証明書署名要求を生成し、応答として送られてきた証明書または証明連鎖をインポートする (<option>certreq</option> サブコマンドと <option>import</option> サブコマンドを参照)</para>
</listitem><listitem><para>元の (不要になった) エントリを削除する (<option>delete</option> コマンドを参照)</para>
</listitem></orderedlist>
<para>自己署名証明書を生成するには、<option>selfcert</option> サブコマンドを使います。たとえば、次のようにします。<informalexample><screen>example% <userinput>keytool -selfcert -alias dukeNew -keypass 92kqmp
-dname "cn=Duke Smith, ou=Purchasing, o=BlueSoft, c=US"</userinput></screen>
</informalexample><?Pub Caret></para>
<para>生成された証明書は、指定した別名 (この例では <literal>dukeNew</literal>) によって特定されるキーストアエントリに、要素を 1 つだけ持つ証明連鎖として格納されます。該当するキーストアエントリの既存の証明連鎖は、新しい証明連鎖によって置き換えられます。</para>
</refsect2>
</refsect1>
<refsect1><title>&usge-tt;</title>
<para>以下では、サブコマンドとそのオプションについて説明します。コマンドとオプションを指定するときは、次の点に注意してください。</para>
<para><emphasis>注:</emphasis></para>
<itemizedlist>
<listitem><para>どのコマンド名およびオプション名にも先頭にマイナス記号 (-) が付く</para>
</listitem><listitem><para>各コマンドのオプションは任意の順序で指定できる</para>
</listitem><listitem><para>イタリック体になっていないすべての項目、または中括弧 (<literal>{ }</literal>) か角括弧 (<literal>[ ]</literal>) で囲まれているすべての項目は、そのとおりに指定する必要がある</para>
</listitem><listitem><para>オプションを囲む中括弧は、一般に、そのオプションをコマンド行で指定しなかった場合に、既定値が使われることを意味する。中括弧は、<option>v</option>、<option>rfc</option>、および <option>J</option> オプションを囲むのにも使われるが、これらのオプションはコマンド行で指定された場合にのみ意味を持つ (つまり、これらのオプションには、オプション自体を指定しないこと以外に「既定値」は存在しない)</para>
</listitem><listitem><para>オプションを囲む角括弧は、そのオプションをコマンド行で指定しなかった場合に、値の入力を求められることを意味する。ただし、<option>keypass</option> オプションをコマンド行で指定しなかった場合は、<command>keytool</command> がキーストアのパスワードから非公開鍵の復元を試みる。ユーザは、この試みが失敗した場合に非公開鍵の入力を求められる</para>
</listitem><listitem><para>イタリック体の項目の実際の値 (オプションの値) は、ユーザが指定する必要がある。たとえば、<option>printcert</option> サブコマンドの形式は次のとおりである<informalexample><screen>example% <userinput>keytool -printcert [-file <replaceable>cert_file</replaceable>] [-v]</userinput></screen>
</informalexample></para>
<para><option>printcert</option> サブコマンドを指定するときは、<replaceable>cert_file</replaceable> の代わりに実際のファイル名を指定する。次に例を示す<informalexample><screen>example% <userinput>keytool -printcert -file VScert.cer</userinput></screen>
</informalexample></para>
</listitem><listitem><para>オプションの値に空白 (スペース) が含まれている場合は、値を引用符で囲む必要がある</para>
</listitem><listitem><para><option>help</option> サブコマンドはデフォルトのコマンドである。たとえば、次のようにコマンド行を指定したとする <informalexample><screen>example% <userinput>keytool</userinput></screen>
</informalexample>これは、次のように指定することと同じである<informalexample><screen>example% <userinput>keytool -help</userinput></screen>
</informalexample></para>
</listitem></itemizedlist>
<refsect2><title>オプションの既定値</title>
<indexterm id="keytool-1-indx-18"><primary sortas="keytool">keytool &mdash; key and certificate management tool</primary><secondary>Option Defaults</secondary></indexterm>
<para>オプションの既定値は、次のとおりです。<variablelist termlength="narrow"><varlistentry><term><option>alias</option></term><listitem><para>&ldquo;mykey&rdquo;</para>
</listitem></varlistentry>
<varlistentry><term><option>keyalg</option></term><listitem><para>&ldquo;DSA&rdquo;</para>
</listitem></varlistentry>
<varlistentry><term><option>keysize</option></term><listitem><para>1024</para>
</listitem></varlistentry>
<varlistentry><term><option>validity</option></term><listitem><para>90</para>
</listitem></varlistentry>
<varlistentry><term><option>keystore</option></term><listitem><para>ユーザのホームディレクトリの <filename>.keystore</filename> というファイル</para>
</listitem></varlistentry>
<varlistentry><term><option>file</option></term><listitem><para>読み込みの場合は標準入力、書き込みの場合は標準出力</para>
</listitem></varlistentry>
</variablelist></para>
<para>署名アルゴリズム (<option>sigalg</option> オプション) は、基になる非公開鍵のアルゴリズムから派生します。基になる非公開鍵のタイプが DSA であり、<option>sigalg</option> 非公開鍵のタイプが RSA である場合、<option>sigalg</option> は既定値で MD5withRSA になります。</para>
</refsect2>
<refsect2><title>ほとんどのサブコマンドで使われるオプション</title>
<indexterm id="keytool-1-indx-19"><primary sortas="keytool">keytool &mdash; key and certificate management tool</primary><secondary>Options that Appear for Most Subcommands</secondary></indexterm>
<para><option>v</option> オプションは、<option>help</option> を除くすべてのサブコマンドで使用できます。このオプションを指定した場合、コマンドは「冗長」モードで実行され、詳細な証明書情報が出力されます。</para>
<para>また、<option>J</option><replaceable>javaoption</replaceable> オプションも、任意のサブコマンドで使用できます。このオプションを指定した場合、指定された <replaceable>javaoption</replaceable> 文字列が Java インタプリタに直接渡されます。<command>keytool</command> は、実際には Java インタプリタに対する「ラッパー」です。このオプションには、空白を含めることはできません。このオプションは、実行環境またはメモリ使用を調整する場合に便利です。指定できるインタプリタオプションを一覧表示するには、コマンド行で <command>java</command> <option>h</option>または <command>java</command> <option>X</option> と入力してください。</para>
<para>次の 3 つのオプションは、キーストアに対する操作を行うすべてのコマンドで指定できます。</para>
<variablelist termlength="wholeline"><varlistentry><term><option>storetype</option> <replaceable>storetype</replaceable> </term><listitem><para>この修飾子は、インスタンスを生成するキーストアのタイプを指定します。デフォルトのキーストアタイプは、セキュリティプロパティファイル内の keystore.type プロパティの値で指定されたタイプです。この値は、<literal>java.security.KeyStore</literal> の static <literal>getDefaultType</literal> メソッドで取得できます。</para>
</listitem></varlistentry>
<varlistentry><term><option>keystore</option> <replaceable>keystore</replaceable> </term><listitem><para>キーストア (データベースファイル) の場所を指定します。デフォルトは、ユーザのホームディレクトリ内のファイル <literal>.keystore</literal> です。ユーザのホームディレクトリは、<literal>user.home</literal> システムプロパティによって決まります。Solaris システムの場合、<literal>user.home</literal> はデフォルトでユーザのホームディレクトリになっています。</para>
</listitem></varlistentry>
<varlistentry><term><option>storepass</option> <replaceable>storepass</replaceable> </term><listitem><para>キーストアの完全性を保護するために使うパスワードを指定します。<replaceable>storepass</replaceable> は、6 文字以上でなければなりません。指定したパスワードは、キーストアの内容にアクセスするすべてのサブコマンドで使われます。この種のサブコマンドを実行するときに、コマンド行で <option>storepass</option> オプションを指定しなかった場合は、パスワードの入力を求められます。</para>
</listitem></varlistentry>
<varlistentry><term><option>provider</option> <replaceable>provider_class_name</replaceable> </term><listitem><para>サービスプロバイダがセキュリティプロパティファイルのリストに入っていないときに、暗号化サービスプロバイダのマスタークラスファイルの名前を指定します。</para>
</listitem></varlistentry>
</variablelist>
<para>キーストアから情報を取り出す場合は、パスワードを省略できます。パスワードを省略すると、取り出す情報の完全性をチェックできないので、警告が表示されます。</para>
<para>パスワードの扱いには十分注意する必要があります。後述の「パスワードに関する注意事項」を参照してください。</para>
</refsect2>
<refsect2><title>パスワードに関する注意事項</title>
<indexterm id="keytool-1-indx-20"><primary sortas="keytool">keytool &mdash; key and certificate management tool</primary><secondary>Warning Regarding Passwords</secondary></indexterm>
<para>キーストアに対する操作を行うほとんどのサブコマンドでは、ストアのパスワードが必要です。また、一部のサブコマンドでは、非公開鍵のパスワードが必要になることがあります。</para>
<para>パスワードはコマンド行で指定できます (ストアのパスワードには <option>storepass</option> オプション、非公開鍵のパスワードには <option>keypass</option> オプションを使用)。ただし、テストを目的とする場合、または安全であることがわかっているシステムで実行する場合以外は、コマンド行やスクリプトでパスワードを指定しないでください。</para>
<para>必要なパスワードのオプションをコマンド行で指定しなかった場合は、パスワードの入力を求められます。password プロンプトでパスワードを入力すると、入力したパスワードがエコーされ、そのまま画面に表示されます。このため、周囲にほかのユーザがいる場合は、パスワードを見られないように注意してください。</para>
</refsect2>
<refsect2><title>サブコマンド</title>
<indexterm id="keytool-1-indx-21"><primary sortas="keytool">keytool &mdash; key and certificate management tool</primary><secondary>SUBCOMMANDS</secondary></indexterm>
<para>&usge-tt; も参照してください。</para>
</refsect2>
<refsect2><title>キーストアへのデータの追加</title>
<indexterm id="keytool-1-indx-22"><primary sortas="keytool">keytool &mdash; key and certificate management tool</primary><secondary>Adding Data to the Keystore</secondary></indexterm>
<cmdsynopsis><command><option>genkey</option></command><arg choice="req"><option>alias</option> <replaceable>alias</replaceable></arg><arg choice="req"><option>keyalg</option> <replaceable>keyalg</replaceable></arg><arg choice="req"><option>keysize</option> <replaceable>keysize</replaceable></arg><arg choice="req"><option>sigalg</option> <replaceable>sigalg</replaceable></arg><arg choice="opt"><option>dname</option> <replaceable>dname</replaceable></arg><arg choice="opt"><option>keypass</option> <replaceable>keypass</replaceable></arg><arg choice="req"><option>validity</option> <replaceable>valDays</replaceable></arg><arg choice="req"><option>storetype</option> <replaceable>storetype</replaceable></arg><arg choice="req"><option>keystore</option> <replaceable>keystore</replaceable></arg><arg
choice="opt"><option>storepass</option> <replaceable>storepass</replaceable></arg><arg><option>provider</option> <replaceable>provider_class_name</replaceable></arg><arg choice="req"><option>v</option></arg><arg choice="req"><option>J</option><replaceable>javaoption</replaceable></arg>
</cmdsynopsis>
<para>鍵のペア (公開鍵および関連する非公開鍵) を生成します。公開鍵は X.509 v1 自己署名証明書でラップされます。証明書は、単一の要素を持つ証明連鎖として格納されます。この証明連鎖と非公開鍵は、<replaceable>alias</replaceable> で特定される新しいキーストアエントリに格納されます。</para>
<para><replaceable>keyalg</replaceable> には、鍵のペアを生成するのに使うアルゴリズムを指定し、<replaceable>keysize</replaceable> には、生成する各鍵のサイズを指定します。<replaceable>sigalg</replaceable> には、自己署名証明書に署名を付けるときに使うアルゴリズムを指定します。このアルゴリズムは、<replaceable>keyalg</replaceable> と互換性のあるものでなければなりません。「サポートされるアルゴリズムと鍵のサイズ」を参照してください。</para>
<para><replaceable>dname</replaceable> には、<replaceable>alias</replaceable> に関連付け、自己署名証明書の issuer フィールドと subject フィールドとして使う X.500 識別名を指定します。コマンド行で識別名を指定しなかった場合は、識別名の入力を求められます。</para>
<para><replaceable>keypass</replaceable> には、生成される鍵のペアのうち、非公開鍵を保護するのに使うパスワードを指定します。パスワードを指定しなかった場合は、パスワードの入力を求められます。このとき、Enter キーを押すと、キーストアのパスワードと同じパスワードが鍵のパスワードに設定されます。<replaceable>keypass</replaceable> は、6 文字以上でなければなりません。パスワードの扱いには十分注意する必要があります。「パスワードに関する注意事項」を参照してください。</para>
<para><replaceable>valDays</replaceable> には、証明書の有効日数を指定します</para>
<cmdsynopsis><command><option>import</option></command><arg choice="req"><option>alias</option> <replaceable>alias</replaceable></arg><arg choice="req"><option>file</option> <replaceable>cert_file</replaceable></arg><arg choice="opt"><option>keypass</option> <replaceable>keypass</replaceable></arg><arg choice="req"><option>noprompt</option></arg><arg choice="req"><option>trustcacerts</option></arg><arg choice="req"><option>storetype</option> <replaceable>storetype</replaceable></arg><arg choice="req"><option>keystore</option> <replaceable>keystore</replaceable></arg><arg choice="opt"><option>storepass</option> <replaceable>storepass</replaceable></arg><arg><option>provider</option> <replaceable>provider_class_name</replaceable></arg><arg choice="req"><option>v</option></arg><arg choice="req"><option>
J</option><replaceable>javaoption</replaceable></arg>
</cmdsynopsis>
<para>ファイル <replaceable>cert_file</replaceable> から証明書または証明連鎖 (証明連鎖の場合は、PKCS#7 形式の応答で提供されるもの) を読み込み、<replaceable>alias</replaceable> によって特定されるキーストアエントリに格納します。証明書または PKCS#7 応答を標準入力から読み込みます。<command>keytool</command> では、X.509 v1、v2、v3 の証明書、および、PKCS#7 形式の証明書から構成されている PKCS#7 形式の証明連鎖をインポートできます。インポートするデータは、バイナリエンコーディング方式、またはプリント可能エンコーディング方式 (Base64 エンコーディングとも呼ばれる) のどちらかで提供する必要があります。プリント可能エンコーディング方式は、インターネット RFC 1421 証明書エンコーディング規格で定義されています。このエンコーディング方式の場合、証明書は「-----BEGIN」で始まる文字列で開始され、「-----END」で始まる文字列で終了しなければなりません。</para>
<para>新しく信頼できる証明書をインポートする場合、キーストアに <replaceable>alias</replaceable> が存在していてはいけません。<command>keytool</command> は、キーストアに証明書を追加する前に、キーストア内にすでに存在する信頼できる証明書を使って、インポートする証明書から (ルート CA の) 自己署名証明書に至るまでの信頼の連鎖の構築を試みます。</para>
<para><option>trustcacerts</option> オプションが指定されている場合は、信頼の連鎖を構築するときに、ほかの証明書も考慮されます。考慮の対象となる証明書は、<literal>cacerts</literal> という名前のファイルに含まれる証明書です。このファイルは、JDK セキュリティプロパティディレクトリ <filename>java.home/lib/security</filename> にあります。<literal>java.home</literal> は、JDK のインストール先ディレクトリです。<literal>cacerts</literal> ファイルは、<acronym>CA</acronym> の証明書を含む、システム全体のキーストアです。システム管理者は、キーストアタイプに jks を指定することで、<command>keytool</command> を使ってこのファイルの構成と管理を行うことができます。<literal>cacerts</literal> キーストアファイルは、次に示す X.500 識別名を持つ 5 つの VeriSign ルート CA 証明書を含んだ状態で出荷されています。</para>
<orderedlist>
<listitem><para>OU=Class 1 Public Primary Certification Authority, O="VeriSign, Inc.", C=US</para>
</listitem><listitem><para>OU=Class 2 Public Primary Certification Authority, O="VeriSign, Inc.", C=US</para>
</listitem><listitem><para>OU=Class 3 Public Primary Certification Authority, O="VeriSign, Inc.", C=US</para>
</listitem><listitem><para>OU=Class 4 Public Primary Certification Authority, O="VeriSign, Inc.", C=US</para>
</listitem><listitem><para>OU=Secure Server Certification Authority, O="RSA Data Security, Inc.", C=US</para>
</listitem></orderedlist>
<para><literal>cacerts</literal> キーストアファイルの初期パスワードは、<literal>changeit</literal> です。システム管理者は、JDK のインストール後、このファイルのパスワードとデフォルトアクセス権を変更する必要があります。</para>
<para><command>keytool</command> が、インポートする証明書から自己署名証明書 (キーストアまたは <literal>cacerts</literal> ファイルに含まれている自己署名証明書) に至るまでの信頼のパスの構築に失敗した場合は、インポートする証明書の情報を表示し、ユーザに確認を求めます。この場合は、表示された証明書のフィンガープリントと、ほかのなんらかの (信頼できる) 情報源 (証明書の所有者本人など) から入手したフィンガープリントとを比較します。「信頼できる証明書」として証明書をインポートするときは、証明書が有効であることを慎重に確認する必要があります。詳細は、「信頼できる証明書のインポートに関する注意事項」を参照してください。インポート操作は、証明書を確認する時点で中止できます。ただし、<option>noprompt</option> オプションが指定されている場合、ユーザとの対話は行われません。</para>
<para>証明書応答をインポートするときは、キーストア内の信頼できる証明書、および (<option>trustcacerts</option> オプションが指定されている場合は) <literal>cacerts</literal> キーストアファイルで構成された証明書を使って証明書応答が検査されます。</para>
<para>証明書応答が単一の X.509 証明書である場合、<command>keytool</command> は、証明書応答から (ルート <acronym>CA</acronym> の) 自己署名証明書に至るまでの信頼連鎖の確立を試みます。証明書応答と、証明書応答の認証に使われる証明書の階層構造は、<replaceable>alias</replaceable> の新しい証明書連鎖を形成します。</para>
<para>証明書応答が PKCS#7 形式の証明連鎖である場合、<command>keytool</command> は、まず連鎖を並べ替えて、ユーザの証明書が最初に、ルート <acronym>CA</acronym> の自己署名証明書が最後にくるようにしたあと、証明書応答に含まれるルート <acronym>CA</acronym> の証明書と、キーストア内または (<option>trustcacerts</option> オプションが指定されている場合は) <literal>cacerts</literal> キーストアファイル内の信頼できる証明書とをすべて比較し、一致するものがあるかどうかを調べます。一致するものが見つからなかった場合は、ルート <acronym>CA</acronym> の証明書の情報を表示し、ユーザに確認を求めます。この場合は、表示された証明書のフィンガープリントと、ほかのなんらかの (信頼できる) 情報源 (ルート <acronym>CA</acronym> 自身など) から入手したフィンガープリントとを比較します。インポート操作は、証明書を確認する時点で中止できます。ただし、<option>noprompt</option> オプションが指定されている場合、ユーザとの対話は行われません。</para>
<para><replaceable>alias</replaceable> に関連付けられた以前の証明連鎖は、新しい証明連鎖によって置き換えられます。以前の証明連鎖を新しい証明連鎖で置き換えることができるのは、有効な keypass、つまり該当するエントリの非公開鍵を保護するためのパスワードを指定した場合だけです。パスワードを指定しておらず、非公開鍵のパスワードがキーストアのパスワードと異なる場合は、非公開鍵のパスワードの入力を求められます。パスワードの扱いには十分注意する必要があります。「パスワードに関する注意事項」を参照してください。</para>
<cmdsynopsis><command><option>selfcert</option></command><arg choice="req"><option>alias</option> <replaceable>alias</replaceable></arg><arg choice="req"><option>sigalg</option> <replaceable>sigalg</replaceable></arg><arg choice="req"><option>dname</option> <replaceable>dname</replaceable></arg><arg choice="req"><option>validity</option> <replaceable>valDays</replaceable></arg><arg choice="opt"><option>keypass</option> <replaceable>keypass</replaceable></arg><arg choice="req"><option>storetype</option> <replaceable>storetype</replaceable></arg><arg choice="req"><option>keystore</option> <replaceable>keystore</replaceable></arg><arg choice="opt"><option>storepass</option> <replaceable>storepass</replaceable></arg><arg><option>provider</option> <replaceable>provider_class_name</replaceable></arg>
<arg choice="req"><option>v</option></arg><arg choice="req"><option>J</option><replaceable>javaoption</replaceable></arg>
</cmdsynopsis>
<para><replaceable>alias</replaceable> に関連付けられた非公開鍵と公開鍵を含むキーストアの情報を使って、X.509 v1 自己署名証明書を生成します。コマンド行で <replaceable>dname</replaceable> が指定されている場合は、証明書の issuer フィールドと subject フィールドの両方に対して、<replaceable>dname</replaceable> が X.500 識別名として使われます。<replaceable>dname</replaceable> が指定されていない場合は、(既存の証明連鎖の最後の) <replaceable>alias</replaceable> に関連付けられた X.500 識別名が使われます。</para>
<para>生成された証明書は、単一の要素を持つ証明連鎖として、<replaceable>alias</replaceable> で特定されるキーストアエントリに格納されます。該当するエントリの既存の証明連鎖は、新しい証明連鎖によって置き換えられます。</para>
<para><replaceable>sigalg</replaceable> には、証明書に署名を付けるときに使うアルゴリズムを指定します。「サポートされるアルゴリズムと鍵のサイズ」を参照してください。</para>
<para>非公開鍵はキーストア内ではパスワードによって保護されているので、非公開鍵にアクセスするには、適切なパスワードを提供する必要があります。コマンド行で <replaceable>keypass</replaceable> を指定しておらず、非公開鍵のパスワードがキーストアのパスワードと異なる場合は、非公開鍵のパスワードの入力を求められます。パスワードの扱いには十分注意する必要があります。「パスワードに関する注意事項」を参照してください。</para>
<para><replaceable>valDays</replaceable> には、証明書の有効日数を指定します。</para>
<cmdsynopsis><command><option>identitydb</option></command><arg choice="req"><option>file</option> <replaceable>idb_file</replaceable></arg><arg choice="req"><option>storetype</option> <replaceable>storetype</replaceable></arg><arg choice="req"><option>keystore</option> <replaceable>keystore</replaceable></arg><arg choice="opt"><option>storepass</option> <replaceable>storepass</replaceable></arg><arg><option>provider</option> <replaceable>provider_class_name</replaceable></arg><arg choice="req"><option>v</option></arg><arg choice="req"><option>J</option><replaceable>javaoption</replaceable></arg>
</cmdsynopsis>
<para>ファイル <replaceable>idb_file</replaceable> から JDK 1.1.x 形式のアイデンティティデータベースを読み込み、アイデンティティデータベースのエントリをキーストアに追加します。ファイルが指定されていない場合は、標準入力からアイデンティティデータベースを読み込みます。キーストアが存在しない場合は、作成されます。</para>
<para>アイデンティティデータベースのエントリ (「アイデンティティ」) のうち、キーストアにインポートされるのは、信頼できるものとしてマークされたエントリだけです。その他のすべてのエントリは無視されます。信頼できるアイデンティティごとに、キーストアエントリが 1 つ作成されます。アイデンティティの名前は、キーストアエントリの「別名」として使われます。</para>
<para>信頼できるアイデンティティからのすべての非公開鍵は、どれも同じパスワード <replaceable>storepass</replaceable> で暗号化されます。このパスワードは、キーストアの完全性を保護するために使われるパスワードと同じです。<command>keytool</command> の <option>keypasswd</option> コマンドのオプションを使えば、あとで個別に非公開鍵にパスワードを割り当てることができます。</para>
<para>アイデンティティデータベース内のアイデンティティは、それぞれが同じ公開鍵を認証する複数の証明書を含んでいることがあります。一方、非公開鍵を格納するキーストアの鍵エントリに含まれるのは、その非公開鍵と、単一の「証明連鎖」(最初は単一の証明書だけ) であり、非公開鍵に対応する公開鍵は連鎖内の最初の証明書に含まれています。アイデンティティから情報をインポートする場合は、アイデンティティの最初の証明書だけがキーストアに格納されます。これは、アイデンティティデータベース内のアイデンティティの名前が、対応するキーストアエントリの別名として使われ、別名はキーストア内で一意であるためです。</para>
</refsect2>
<refsect2><title>データのエクスポート</title>
<indexterm id="keytool-1-indx-23"><primary sortas="keytool">keytool &mdash; key and certificate management tool</primary><secondary>Exporting Data</secondary></indexterm>
<cmdsynopsis><command><option>certreq</option></command><arg choice="req"><option>alias</option> <replaceable>alias</replaceable></arg><arg choice="req"><option>sigalg</option> <replaceable>sigalg</replaceable></arg><arg choice="req"><option>file</option> <replaceable>certreq_file</replaceable></arg><arg choice="opt"><option>keypass</option> <replaceable>keypass</replaceable></arg><arg choice="req"><option>storetype</option> <replaceable>storetype</replaceable></arg><arg choice="req"><option>keystore</option> <replaceable>keystore</replaceable></arg><arg choice="opt"><option>storepass</option> <replaceable>storepass</replaceable></arg><arg><option>provider</option> <replaceable>provider_class_name</replaceable></arg><arg choice="req"><option>v</option></arg><arg choice="req"><option>J</option><replaceable>
javaoption</replaceable></arg>
</cmdsynopsis>
<para>PKCS#10 形式を使って証明書署名要求 (<acronym>CSR</acronym>) を生成します。</para>
<para><acronym>CSR</acronym> は、証明書発行局 (<acronym>CA</acronym>) に送信することを目的としたものです。<acronym>CA</acronym> は、証明書要求者を (通常はオフラインで) 認証し、証明書または証明連鎖を送り返します。この証明書または証明連鎖は、キーストア内の既存の証明連鎖 (最初は 1 つの自己署名証明書から構成される) に置き換えて使います。</para>
<para><replaceable>alias</replaceable> に関連付けられた非公開鍵と X.500 識別名は、PKCS#10 証明書要求を作成するのに使われます。非公開鍵はキーストア内ではパスワードによって保護されているので、非公開鍵にアクセスするには、適切なパスワードを提供する必要があります。コマンド行で <replaceable>alias</replaceable> を指定しておらず、非公開鍵のパスワードがキーストアのパスワードと異なる場合は、非公開鍵のパスワードの入力を求められます。</para>
<para>パスワードの扱いには十分注意する必要があります。「パスワードに関する注意事項」を参照してください。</para>
<para><replaceable>sigalg</replaceable> には、<acronym>CSR</acronym> に署名を付けるときに使うアルゴリズムを指定します。「サポートされるアルゴリズムと鍵のサイズ」を参照してください。</para>
<para><acronym>CSR</acronym> は、ファイル <replaceable>certreq_file</replaceable> に格納されます。ファイルが指定されていない場合は、標準出力に CSR が出力されます。</para>
<para><acronym>CA</acronym> からの応答をインポートするには、<command>import</command> コマンドを使います。</para>
<cmdsynopsis><command><option>export</option></command><arg choice="req"><option>alias</option> <replaceable>alias</replaceable></arg><arg choice="req"><option>file</option> <replaceable>cert_file</replaceable></arg><arg choice="req"><option>storetype</option> <replaceable>storetype</replaceable></arg><arg choice="req"><option>keystore</option> <replaceable>keystore</replaceable></arg><arg choice="opt"><option>storepass</option> <replaceable>storepass</replaceable></arg><arg><option>provider</option> <replaceable>provider_class_name</replaceable></arg><arg choice="req"><option>rfc</option></arg><arg choice="req"><option>v</option></arg><arg choice="req"><option>J</option><replaceable>javaoption</replaceable></arg>
</cmdsynopsis>
<para><replaceable>alias</replaceable> に関連付けられた証明書を (キーストアから) 読み込み、ファイル <replaceable>cert_file</replaceable> に格納します。</para>
<para>ファイルが指定されていない場合は、標準出力に証明書が出力されます。</para>
<para>デフォルトでは、バイナリエンコーディングの証明書が出力されます。ただし、<option>rfc</option> オプションを指定した場合は、プリント可能エンコーディング方式の証明書が出力されます。プリント可能エンコーディング方式は、インターネット RFC 1421 証明書エンコーディング規格で定義されています。</para>
<para><replaceable>alias</replaceable> が、信頼できる証明書を参照している場合は、該当する証明書が出力されます。それ以外の場合、<replaceable>alias</replaceable> は、関連付けられた証明連鎖を持つ鍵エントリを参照します。この場合は、連鎖内の最初の証明書が返されます。この証明書は、<replaceable>alias</replaceable> によって表されるエンティティの公開鍵を認証する証明書です。</para>
</refsect2>
<refsect2><title>データの表示</title>
<indexterm id="keytool-1-indx-24"><primary sortas="keytool">keytool &mdash; key and certificate management tool</primary><secondary>Displaying Data</secondary></indexterm>
<cmdsynopsis><command><option>list</option></command><arg choice="req"><option>storetype</option> <replaceable>storetype</replaceable></arg><arg choice="req"><option>keystore</option> <replaceable>keystore</replaceable></arg><arg choice="opt"><option>storepass</option> <replaceable>storepass</replaceable></arg><arg><option>provider</option> <replaceable>provider_class_name</replaceable></arg><group choice="req"><arg choice="plain"><option>v</option></arg><arg choice="plain"><option>rfc</option></arg></group><arg choice="req"><option>J</option><replaceable>javaoption</replaceable></arg>
</cmdsynopsis>
<para><replaceable>alias</replaceable> で特定されるキーストアエントリの内容を (標準出力に) 出力します。別名が指定されていない場合は、キーストア全体の内容が表示されます。</para>
<para>このサブコマンドは、デフォルトでは証明書の MD5 フィンガープリントを表示します。<option>v</option> オプションが指定されている場合は、所有者、発行者、シリアル番号などの付加的な情報とともに、人間が読むことのできる形式で証明書が表示されます。<option>rfc</option> オプションが指定されている場合は、プリント可能なエンコーディング方式で証明書の内容が表示されます。プリント可能エンコーディング方式は、インターネット RFC 1421 証明書エンコーディング規格で定義されています。</para>
<para><option>v</option> オプションと <option>rfc</option> オプションとを同時に指定することはできません。</para>
<cmdsynopsis><command><option>printcert</option></command><arg choice="req"><option>file</option> <replaceable>cert_file</replaceable></arg><arg choice="req"><option>v</option></arg><arg choice="req"><option>J</option><replaceable>javaoption</replaceable></arg>
</cmdsynopsis>
<para>ファイル <replaceable>cert_file</replaceable> から証明書を読み込み、人間が読むことのできる形式で証明書の内容を表示します。ファイルが指定されていない場合は、標準入力から証明書を読み込みます。</para>
<para>証明書は、バイナリエンコーディングまたはプリント可能エンコーディング方式で表示できます。プリント可能エンコーディング方式は、インターネット RFC 1421 証明書エンコーディング規格で定義されています。</para>
<para><emphasis>注:</emphasis> このコマンドはキーストアとは関係なく動作します。</para>
</refsect2>
<refsect2><title>キーストアの管理</title>
<indexterm id="keytool-1-indx-25"><primary sortas="keytool">keytool &mdash; key and certificate management tool</primary><secondary>Managing the Keystore</secondary></indexterm>
<cmdsynopsis><command><option>keyclone</option></command><arg choice="req"><option>alias</option> <replaceable>alias</replaceable></arg><arg choice="opt"><option>dest</option> <replaceable>dest_alias</replaceable></arg><arg choice="opt"><option>keypass</option> <replaceable>keypass</replaceable></arg><arg choice="req"><option>new</option> <replaceable>new_keypass</replaceable></arg><arg choice="req"><option>storetype</option> <replaceable>storetype</replaceable></arg><arg choice="req"><option>keystore</option> <replaceable>keystore</replaceable></arg><arg choice="opt"><option>storepass</option> <replaceable>storepass</replaceable></arg><arg><option>provider</option> <replaceable>provider_class_name</replaceable></arg><arg choice="req"><option>v</option></arg><arg choice="req"><option>J</option><replaceable>
javaoption</replaceable></arg>
</cmdsynopsis>
<para>元のエントリと同じ非公開鍵と認証連鎖を持つ、新しいキーストアエントリを作成します。</para>
<para><replaceable>alias</replaceable>には、元のエントリを指定します。alias を指定しなかった場合は、既定値の <literal>mykey</literal> が使われます。<replaceable>dest_alias</replaceable> には、新しい (複製先の) エントリを指定します。コマンド行で複製先の別名を指定しなかった場合は、別名の入力を求められます。</para>
<para>非公開鍵のパスワードがキーストアのパスワードと異なる場合は、有効な <replaceable>keypass</replaceable> が指定された場合にのみ、エントリが複製されます。このとき指定するのは、<replaceable>alias</replaceable> に関連付けられた非公開鍵を保護するためのパスワードです。コマンド行でこのパスワードが指定されず、非公開鍵のパスワードがキーストアのパスワードと異なる場合は、パスワードの入力を求められます。複製されたエントリの非公開鍵は、必要に応じて別のパスワードで保護できます。コマンド行で <option>new</option> オプションを指定しなかった場合は、新しいエントリのパスワードの入力を求められます。このとき、複製された非公開鍵に対して同じパスワードを指定できます。</para>
<para>パスワードの扱いには十分注意する必要があります。「パスワードに関する注意事項」を参照してください。</para>
<para>このサブコマンドは、ある与えられた鍵のペアに対応する複数の認証連鎖を確立するために使用できます。また、バックアップを目的として使用することもできます。</para>
<cmdsynopsis><command><option>storepasswd</option></command><arg choice="req"><option>new</option> <replaceable>new_storepass</replaceable></arg><arg choice="req"><option>storetype</option> <replaceable>storetype</replaceable></arg><arg choice="req"><option>keystore</option> <replaceable>keystore</replaceable></arg><arg choice="opt"><option>storepass</option> <replaceable>storepass</replaceable></arg><arg><option>provider</option> <replaceable>provider_class_name</replaceable></arg><arg choice="req"><option>v</option></arg><arg choice="req"><option>J</option><replaceable>javaoption</replaceable></arg>
</cmdsynopsis>
<para>キーストアの内容の完全性を保護するために使うパスワードを変更します。<replaceable>new_storepass</replaceable> には、新しいパスワードを指定します。<replaceable>new_storepass</replaceable> は、6 文字以上でなければなりません。</para>
<para>パスワードの扱いには十分注意する必要があります。「パスワードに関する注意事項」を参照してください。</para>
<cmdsynopsis><command><option>keypasswd</option></command><arg choice="req"><option>alias</option> <replaceable>alias</replaceable></arg><arg choice="opt"><option>keypass</option> <replaceable>old_keypass</replaceable></arg><arg choice="opt"><option>new</option> <replaceable>new_keypass</replaceable></arg><arg choice="req"><option>storetype</option> <replaceable>storetype</replaceable></arg><arg choice="req"><option>keystore</option> <replaceable>keystore</replaceable></arg><arg choice="opt"><option>storepass</option> <replaceable>storepass</replaceable></arg><arg><option>provider</option> <replaceable>provider_class_name</replaceable></arg><arg choice="req"><option>v</option></arg><arg choice="req"><option>J</option><replaceable>javaoption</replaceable></arg>
</cmdsynopsis>
<para><replaceable>alias</replaceable> によって特定される非公開鍵を保護するためのパスワードを、<replaceable>old_keypass</replaceable> から <replaceable>new_keypass</replaceable> に変更します。</para>
<para>コマンド行で <command>keypass</command> オプションを指定しておらず、非公開鍵のパスワードがキーストアのパスワードと異なる場合は、非公開鍵のパスワードの入力を求められます。</para>
<para>コマンド行で <option>new</option> オプションを指定しなかった場合は、新しいパスワードの入力を求められます。</para>
<para>パスワードの扱いには十分注意する必要があります。「パスワードに関する注意事項」を参照してください。</para>
<cmdsynopsis><command><option>delete</option></command><arg choice="opt"><option>alias</option> <replaceable>alias</replaceable></arg><arg choice="req"><option>storetype</option> <replaceable>storetype</replaceable></arg><arg choice="req"><option>keystore</option> <replaceable>keystore</replaceable></arg><arg choice="opt"><option>storepass</option> <replaceable>storepass</replaceable></arg><arg><option>provider</option> <replaceable>provider_class_name</replaceable></arg><arg choice="req"><option>v</option></arg><arg choice="req"><option>J</option><replaceable>javaoption</replaceable></arg>
</cmdsynopsis>
<para><replaceable>alias</replaceable> によって特定されるエントリをキーストアから削除します。コマンド行で別名を指定しなかった場合は、別名の入力を求められます。</para>
</refsect2>
<refsect2><title>ヘルプの表示</title>
<indexterm id="keytool-1-indx-26"><primary sortas="keytool">keytool &mdash; key and certificate management tool</primary><secondary>Getting Help</secondary></indexterm>
<cmdsynopsis><command><option>help</option></command>
</cmdsynopsis></refsect2>
</refsect1>
<refsect1><title>&exam-tt;</title>
<para>ここでは、自分の鍵のペアおよび信頼できるエンティティからの証明書を管理するためのキーストアを作成する場合を例として示します。</para>
<example role="example"><title>鍵のペアの生成</title>
<para>公開鍵と非公開鍵のペア、および信頼するエンティティからの証明書を管理するために、キーストアを作成したい場合を想定してみます。</para>
<para>まず、キーストアを作成して鍵のペアを生成する必要があります。次に示すのは、実行するコマンドの例です。<informalexample><screen>example% <userinput>keytool -genkey -dname "cn=Mark Jones, ou=Java, o=Sun, c=US"
-alias business -keypass kpi135 -keystore /working/mykeystore
-storepass ab987c -validity 180</userinput></screen>
</informalexample>(<emphasis>注:</emphasis> 上のコマンド例は、読みやすくするために複数の行に分けてありますが、実際には 1 行で指定する必要があります。</para>
<para>この例では、<literal>working</literal> ディレクトリに <literal>mykeystore</literal> という名前のキーストアを作成し (キーストアはまだ存在していないと仮定して)、作成したキーストアにパスワード <literal>ab987c</literal> を割り当てます。生成する公開鍵と非公開鍵のペアに対応するエンティティの「識別名」は、通称が <literal>Mark Jones</literal>、組織単位が <literal>Java</literal>、組織が <literal>Sun</literal>、2 文字の国番号が <literal>US</literal> です。公開鍵と非公開鍵のサイズはどちらも 1024 ビットで、鍵の作成にはデフォルトの DSA 鍵生成アルゴリズムを使用します。</para>
<para>このコマンドは、公開鍵と識別名情報を含む自己署名証明書 (デフォルトの SHA1withDSA 署名アルゴリズムを使用) を作成します。証明書の有効期間は <literal>180</literal> 日です。証明書は、別名 <literal>business</literal> で特定されるキーストアエントリ内の非公開鍵に関連付けられます。非公開鍵にはパスワード <literal>kpi135</literal> が割り当てられます。</para>
<para>オプションの既定値を使う場合は、上に示したコマンドを大幅に短くすることができます。実際には、オプションを 1 つも指定せずにコマンドを実行することも可能です。既定値を持つオプションでは、オプションを指定しなければ既定値が使われ、必要な値については入力を求められます。たとえば、単に次のように入力することもできます。<informalexample><screen>example% <userinput>keytool -genkey</userinput></screen>
</informalexample></para>
<para>この場合は、<literal>mykey</literal> という別名でキーストアエントリが作成され、新しく生成された鍵のペア、および 90 日間有効な証明書がこのエントリに格納されます。このエントリは、ホームディレクトリ内の <literal>.keystore</literal> という名前のキーストアに置かれます。このキーストアがまだ存在していない場合は、作成されます。識別名情報、キーストアのパスワード、および非公開鍵のパスワードについては、入力を求められます。</para>
<para>以下では、オプションを指定しないで <option>genkey</option> コマンドを実行したものとして例を示します。情報の入力を求められた場合は、最初に示した <option>genkey</option> コマンドの値を入力したものとします (たとえば、非公開鍵のパスワードには <literal>kpi135</literal> と指定)。</para>
</example>
<example role="example"><title>証明書発行局に対する署名付き証明書の要求</title>
<para>現時点で手元にあるのは、1 通の自己署名証明書だけです。証明書に証明書発行局 (<acronym>CA</acronym>) の署名が付いていれば、ほかのユーザから証明書が信頼できる可能性も高くなります。<acronym>CA</acronym> の署名を取得するには、まず、証明書署名要求 (<acronym>CSR</acronym>) を生成します。たとえば、次のようにします。<informalexample><screen>example% <userinput>keytool -certreq -file MarkJ.csr</userinput></screen>
</informalexample></para>
<para><acronym>CSR</acronym> (デフォルト別名 <literal>mykey</literal> によって特定されるエンティティの CSR) が作成され、<literal>MarkJ.csr</literal> という名前のファイルに置かれます。このファイルは、VeriSign などの CA に提出します。<acronym>CA</acronym> は要求者を (通常はオフラインで) 認証し、要求者の公開鍵を認証した署名付きの証明書を送り返します。場合によっては、<acronym>CA</acronym> が証明書の連鎖を返すこともあります。証明書の連鎖では、各証明書が連鎖内のその前の署名者の公開鍵を認証します。</para>
</example>
<example role="example"><title>CA からの証明書のインポート</title>
<para>作成した自己署名証明書は、証明連鎖で置き換える必要があります。証明連鎖では、各証明書が、「ルート」<acronym>CA</acronym>を起点とする連鎖内の次の証明書の署名者の公開鍵を認証します。</para>
<para><acronym>CA</acronym> からの証明書応答をインポートするには、キーストアか、(<option>import</option> コマンドで説明しているように) <literal>cacerts</literal> キーストアファイル内に 1 つ以上の「信頼できる証明書」を必要とします。</para>
<itemizedlist>
<listitem><para>証明書応答が証明連鎖の場合は、連鎖のトップの証明書 (その <acronym>CA</acronym> の公開鍵を認証する「ルート」<acronym>CA</acronym> の証明書) だけを必要とする</para>
</listitem><listitem><para>証明書応答が単一の証明書の場合は、証明書に署名した <acronym>CA</acronym> の発行用の証明書が必要で、その証明書が自己署名されない場合は、さらにその証明書の署名者用の証明書を必要とする。このようにして自己署名される「ルート」<acronym>CA</acronym> の証明書までそれぞれ証明書を必要とする</para>
</listitem></itemizedlist>
<para><literal>cacerts</literal> キーストアファイルは、5 つの VeriSign ルート CA 証明書を含んだ状態で出荷されているので、VeriSign の証明書を、信頼できる証明書としてキーストア内にインポートする必要はない可能性があります。ただし、ほかの <acronym>CA</acronym> に対して署名付き証明書を要求していて、この <acronym>CA</acronym> の公開鍵を認証する証明書が、<literal>cacerts</literal> にまだ追加されていない場合は、該当する CA からの証明書を、「信頼できる証明書」としてインポートする必要があります。</para>
<para>通常、<acronym>CA</acronym> からの証明書は、自己署名証明書、またはほかの <acronym>CA</acronym> によって署名された証明書です (後者の場合は、該当するほかの <acronym>CA</acronym> の公開鍵を認証する証明書も必要)。たとえば、ABC という企業が <acronym>CA</acronym> だとします。このとき、この <acronym>CA</acronym> の公開鍵を認証する自己署名証明書と考えられる <literal>ABCCA.cer</literal> という名前のファイルを、ABC から入手したとします。</para>
<para>「信頼できる証明書」として証明書をインポートする前に、証明書が有効であることを必ず確認してください。まず、証明書の内容を表示し (<option>printcert</option> サブコマンド、または <option>noprompt</option> オプションなしで <option>import</option> サブコマンドを使用)、表示された証明書のフィンガープリントが、期待されるフィンガープリントと一致するかどうかを確認します。証明書を送信した人物に連絡し、この人物が提示した (または安全な公開鍵のリポジトリによって提示される) フィンガープリントと、上のコマンドで表示されたフィンガープリントとを比較します。フィンガープリントが一致すれば、送信途中でほかの何者か (攻撃者など) による証明書のすり替えが行われていないことを確認できます。送信途中でこの種の攻撃が行われていた場合、チェックを行わずに証明書をインポートすると、攻撃者によって署名されたすべてのものを信頼することになります。</para>
<para><literal>ABCCA.cer</literal> を有効な証明書として信頼する場合は、証明書をキーストアに追加できます。たとえば、次のようにします。<informalexample><screen>example% <userinput>keytool -import -alias abc -file ABCCA.cer</userinput></screen>
</informalexample></para>
<para><literal>ABCCA.cer</literal> ファイルのデータを含む「信頼できる証明書」のエントリがキーストア内に作成され、該当するエントリに <literal>abc</literal> という別名が割り当てられます。</para>
</example>
<example role="example"><title>CA からの証明書応答のインポート</title>
<para>証明書署名要求の提出先の <acronym>CA</acronym> の公開鍵を認証する証明書をインポートしたあとは (または同種の証明書がすでに <literal>cacerts</literal> ファイル内に存在している場合は)、証明書応答をインポートし、自己署名証明書を証明連鎖で置き換えることができます。この証明連鎖は、CA の応答が連鎖の場合、証明書署名要求に対する応答として <acronym>CA</acronym> から送り返された証明連鎖です。また、<acronym>CA</acronym> の応答が単一の証明書の場合は、この証明書応答と、インポート先のキーストア内または <literal>cacerts</literal> キーストアファイル内にすでに存在する信頼できる証明書とを使って構築した証明連鎖です。</para>
<para>たとえば、証明書署名要求を VeriSign に送信したとします。送り返された証明書の名前が <literal>VSMarkJ.cer</literal> だとすると、次のようにして応答をインポートできます。<informalexample><screen>example% <userinput>keytool -import -trustcacerts -file VSMarkJ.cer</userinput></screen>
</informalexample></para>
</example>
<example role="example"><title>公開鍵を認証する証明書のエクスポート</title>
<para>たとえば、<citerefentry><refentrytitle>jarsigner</refentrytitle><manvolnum>1</manvolnum></citerefentry> ツールを使って Java ARchive (JAR) ファイルに署名を付けたとします。この <acronym>JAR</acronym> ファイルはクライアントによって使われますが、クライアント側では署名を認証したいと考えています。</para>
<para>クライアントが署名を認証する方法の 1 つに、まず自分の公開鍵の証明書を「信頼できる」エントリとしてクライアントのキーストアにインポートする方法があります。そのためには、証明書をエクスポートして、クライアントに提供します。たとえば、次のようにして、証明書を <literal>MJ.cer</literal> という名前のファイルにコピーします。このエントリには「<literal>mykey</literal>」という別名が使われているとします。<informalexample><screen>example% <userinput>keytool -export -alias mykey -file MJ.cer</userinput></screen>
</informalexample></para>
<para>証明書と署名付き <acronym>JAR</acronym> ファイルを入手したクライアントは、<citerefentry><refentrytitle>jarsigner</refentrytitle><manvolnum>1</manvolnum></citerefentry> ツールを使って署名を認証できます。</para>
</example>
<example role="example"><title>鍵のペアを保持したままでの識別名の変更</title>
<para>所属部課の変更や転勤などによって、識別名が変更されたとします。このような場合は、識別名を更新する一方で、引き続き以前と同じ公開鍵と非公開鍵のペアを使用することができます。たとえば、名前が Susan Miller で、以前に <literal>sMiller</literal> という別名で鍵エントリを作成していたとします。識別名は、次のように指定していました。<informalexample><screen>"cn=Susan Miller, ou=Finance Department, o=BlueSoft, c=us"</screen>
</informalexample></para>
<para>ここで、所属部課が Finance Department から Accounting Department に 変更になったとします。この場合、以前に生成した公開鍵と非公開鍵のペアを使い続けながら識別名を更新するには、次のようにします。まず、鍵エントリをコピー (複製) します。<informalexample><screen>example% <userinput>keytool -keyclone -alias sMiller -dest sMillerNew</userinput></screen>
</informalexample>この例では、ストアのパスワードおよび元の非公開鍵のパスワードと複製先の非公開鍵のパスワードをコマンド行で指定していないので、パスワードの入力を求められます。鍵エントリをコピーしたあとは、連鎖内の最初の証明書が変更後の識別名を使うようにするために、コピーした鍵エントリに関連付けられている証明連鎖を変更する必要があります。まず、適切な名前で自己署名証明書を生成します。<informalexample><screen>example% <userinput>keytool -selfcert -alias sMillerNew
-dname "cn=Susan Miller, ou=Accounting Department, o=BlueSoft, c=us"</userinput></screen>
</informalexample></para>
<para>次に、この新しい証明書の情報に基づいて証明書署名要求を生成します。<informalexample><screen>example% <userinput>keytool -certreq -alias sMillerNew</userinput></screen>
</informalexample></para>
<para><acronym>CA</acronym> の証明書応答を入手したら、応答をインポートします。<informalexample><screen>example% <userinput>keytool -import -alias sMillerNew -file VSSMillerNew.cer</userinput></screen>
</informalexample></para>
<para>証明書応答のインポート後は、古い識別名が使われている元の鍵エントリを削除できます。<informalexample><screen>example% <userinput>keytool -delete -alias sMiller</userinput></screen>
</informalexample></para>
<para></para>
</example>
</refsect1>
<refsect1><title>&attr-tt;</title>
<para><citerefentry><refentrytitle>attributes</refentrytitle><manvolnum>5</manvolnum></citerefentry> のマニュアルページを参照してください。</para>
<informaltable frame="all" orient="port"><tgroup cols="2" colsep="1" rowsep="1"><colspec colnum="1" colname="col1" colwidth="1*" colsep="1" align="left"><colspec colnum="2" colname="col2" colwidth="1*" align="left"><thead><row><entry colname="col1" align="center" valign="top">属性タイプ</entry><entry colname="col2" align="center" valign="top">属性値</entry></row></thead><tbody><row><entry>使用条件</entry><entry>SUNWj3rt, SUNWj3dev</entry></row></tbody></tgroup></informaltable>
</refsect1>
<refsect1><title>&also-tt;</title>
<para><citerefentry><refentrytitle>jar</refentrytitle><manvolnum>1</manvolnum></citerefentry>, <citerefentry><refentrytitle>jarsigner</refentrytitle><manvolnum>1</manvolnum></citerefentry>, <citerefentry><refentrytitle>attributes</refentrytitle><manvolnum>5</manvolnum></citerefentry> </para>
<para>次については、<literal>java.sun.com</literal> を参照または検索してください。</para>
<variablelist termlength="wholeline"><varlistentry><term remap="10"><citetitle>Security in the Java Platform :</citetitle></term><listitem><para><ulink url="http://java.sun.com/docs/books/tutorial/security1.2/index.html">http://java.sun.com/docs/books/tutorial/security1.2/index.html</ulink></para>
</listitem></varlistentry>
</variablelist>
</refsect1>
<!--+ 07/27/00 08:35:00
    | tagMorph:  $Id: tagMorph-engine 1.54 1998/01/19 05:44:48 $
    | tagMorph library:  $Id: libtagMorph.a 1.50 1998/01/19 22:02:51 $
    | sunman-to-solbook 1.17
    +-->
</refentry>
<?Pub *0000066198 0>
